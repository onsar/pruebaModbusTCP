#!/usr/bin/env python
import sys

from pymodbus.client.sync import ModbusTcpClient as ModbusClient
from pymodbus.constants import Endian
from pymodbus.payload import BinaryPayloadDecoder

import configparser

# Librerias para transmitir a emonCMS
import urllib.request
import time

import sched, threading

tx_ok = 0
tx_sent = 0
#################################
# Parseo de variables del .ini
#################################

parser = configparser.ConfigParser()
parser.read('config.ini')

# devuelve una list con todas las secciones
sections = parser.sections()

# Parseo de las variables de emonCMS
#   pendiente detectar errores y parar le script
tx_cms_ip = parser.get('emoncms','cms_ip')
tx_path = parser.get('emoncms','path')
tx_key = parser.get('emoncms','key')

# Lista para incluir los servidores
servers_list=[]
# Lista para incluir los registros
registers_list=[]
# Lista de registros ordenados por sservidor
# [[aa,ab,ac],[ba,bb,bc],[ca,cb,cc],[da,db,dc]]
server_register_list=[]
# Lista de valores de lo registros ordenados por servidor
# [[aa,ab,ac],[ba,bb,bc],[ca,cb,cc],[da,db,dc]]
server_register_values_list=[]



# Listas separadas de servidores y registros
for section in sections:
    if parser.has_option(section,'url'):
        servers_list.append(section)
    if parser.has_option(section,'server'):
        registers_list.append(section)


###########################################
# Uso de ini para la lectura de registros
###########################################
# lista de serrvidores y registros de cada servidor
for server in servers_list:
    registers_temp_list=[]
    values_temp_list=[]
    for register in registers_list:
        if server == parser.get(register,'server'):
            registers_temp_list.append(register)
            # Lista para guardar los resultados
            values_temp_list.append('3')
    server_register_list.append(registers_temp_list)
    server_register_values_list.append(values_temp_list)
print("*" * 4 + ' Servidores')
print(servers_list)
print("*" * 4 + ' Registros agrupados por servidor')
print(server_register_list)

# tx_byteorder = Endian.Little
# tx_wordorder = Endian.Little

###########################################
# definicion de funciones
###########################################

def emoncms_tx(_tx_server,_tx_register,_value):

    global tx_ok
    global tx_sent
    global tx_cms_ip
    global tx_path
    global tx_key

    url = "http://{0}{1}/input/post.json".format(tx_cms_ip,tx_path)
    string_node_name = "?node={0}".format(_tx_server)
    string_name_value = "&json={0}:{1}".format(_tx_register,_value)
    key_write = "&apikey={0}".format(tx_key)
    full_url = url + string_node_name + string_name_value + key_write
    print(full_url)

    #Transmision de datos al servidor emonCMS
    response = urllib.request.urlopen(full_url)
    tx_sent=tx_sent+1
    web_page=response.read()
    print(web_page)
    web_page_str = str(web_page)
    if web_page_str.find("ok") >= 0:
        tx_ok=tx_ok+1

    print('tx_ok: ' + str(tx_ok))

def read_holding_value(tx_server_, tx_register_):

    ###########################################
    # FUNCION preguntar holding valor
    ###########################################

    print('---- ' + tx_register_)

    tx_start = int(parser.get(tx_register_,'start'))
    tx_count = int(parser.get(tx_register_,'registers'))

    tx_unit = int(parser.get(tx_server_,'unit'))
    st_byteorder = parser.get(tx_server_,'byteorder')

    global tx_byteorder
    exec("global tx_byteorder\ntx_byteorder = %s" % (st_byteorder))
    st_wordorder = parser.get(tx_server_,'wordorder')
    global tx_wordorder
    exec("global tx_wordorder\ntx_wordorder = %s" % (st_wordorder))


    register_red = True
    value = 33.33
    global cli
    # res1 = cli.read_holding_registers(tx_start, count=tx_count, unit=tx_unit)

    try:
        res1 = cli.read_holding_registers(tx_start, count=tx_count, unit=tx_unit)

        # print("res1: " + str(res1))
        print('tx_byteorder: '+ tx_byteorder)
        print('tx_wordorder: '+ tx_wordorder)


        decoder = BinaryPayloadDecoder.fromRegisters(res1.registers,
                                                     byteorder= tx_byteorder,
                                                     wordorder= tx_wordorder)


        st_tipe = "decoder.decode_" + parser.get(tx_register_,'tipe') + "()"
        global decoded
        print("global decoded\ndecoded = %s" % (st_tipe))
        exec("global decoded\ndecoded = %s" % (st_tipe))

        value = "%.2f" % decoded

        print('st_tipe: '+ st_tipe)
        #print('value: ' + value)
        print("registros:" + str(res1.registers))


    except:
        print("Error:", sys.exc_info()[0])
        print("Error al leer el registro: " + tx_register_)
        register_red = False

    if register_red == True:
        emoncms_tx(tx_server_,tx_register_,value)

###########################################
# Recorremos los registros
###########################################
def matrix_reading():
    global servers_list
    global server_register_list
    threading.Timer(10.0, matrix_reading).start()
    print("*" * 4 + ' Recorremos servidores y sus registros')
    for s in range(len(servers_list)):

        tx_server = servers_list[s]
        tx_url = parser.get(tx_server,'url')
        tx_port = parser.get(tx_server,'port')

        print('------ ' + tx_server)
        global cli
        cli = ModbusClient(tx_url, port=tx_port)
        connexion = True
        try:
            # sin el assert el fallo en la conexión no se toma como error
            assert cli.connect()
        except:
            connexion = False
            print("Error:", sys.exc_info()[0])
            print("Error en la conexión al Servidor")

        if connexion == True:
            for r in range(len(server_register_list[s])):
                tx_register = server_register_list[s][r]

                read_holding_value(tx_server, tx_register)

def parameters_info():
    threading.Timer(5.0, parameters_info).start()
    location = 'ciudad_transporte'
    parameter='tx_ok'
    value = tx_ok
    emoncms_tx(location,parameter,value)
    parameter='tx_sent'
    value = tx_sent
    emoncms_tx(location,parameter,value)


matrix_reading()
parameters_info()
